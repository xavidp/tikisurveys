---
title: "Tiki surveys Testing"
author: "Xavier de Pedro Puente"
date: "25/01/2016"
output: 
  html_document:
    toc: true
    number_sections: true
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

Interesting Slides from a presentation in VII Jornades de Usuarios de R (R-es)
See Presentation from:
http://files.meetup.com/1781511/useR%20Vignette%20-%20Accessing%20Databases%20from%20R%20-%2020110504.pdf

# Basic params

```{r Basic params, echo=FALSE}

#baseDir <- paste0("/home/xavi/Estudis/", analysisName) # Pentinella
baseDir <- "."
workingDir <- baseDir
setwd(workingDir)
dataRelDir <- "data"
resultsRelDir <- "results"
logsRelDir <- "logs"

folders2create <- c(dataRelDir, resultsRelDir, logsRelDir)
# Start loop over folders
for (folder in folders2create) {
  # Check if folder exists. If not, create it.
  if (!dir.exists(file.path(workingDir, folder))) dir.create(file.path(workingDir, folder))
  }
```

# Install packages

## System packages
You will need unaccent (which reuses iconv system command in the backend) to replace accented characters with their non-accented counterparts. The function iconv from the R package works well with data inside a data.frame, but it seems to produce NA when the string to make the replacement in, is the column name of the dataframe. Therefore, since we need to do this replacement for the data in the csv coming from the tracker, we will do so with a system command to that csv file before reading it into a data.frame in R.

We will also replace some strings there with system program "sed" . See:
* http://www.grymoire.com/Unix/Sed.html 
* http://www.brunolinux.com/02-The_Terminal/Find_and%20Replace_with_Sed.html

You can install them in Debian based machines with:

> sudo apt-get install unaccent sed

## R packages (from CRAN and eventually from Bioconductor)
```{r Install packages, echo=FALSE}
Sys.setenv(GIT_ASKPASS=Sys.getenv("SSH_ASKPASS"))
#############################
# Package dependencies
#############################
## ----librerias, eval=TRUE------------------------------------------------
## Bioconductor
installifnot <- function (pckgName){
  if(!(require(pckgName, character.only=TRUE))){
    source("http://Bioconductor.org/biocLite.R")
    biocLite(pckgName)
  }
}
# Names of packages to be installed from BIOCONDUCTOR if not present yet in this machine
pBIOC <- NULL

if( any(!pBIOC %in% rownames(installed.packages())) ){
  installifnot(pBIOC[!pBIOC %in% rownames(installed.packages())])
}

# Names of packages to be installed from CRAN if not present yet in this machine
pCRAN <- c("devtools",
           "scales",
           "sjPlot",
           "sjmisc",
           "ggplot2",
           "httr",
           "stringi",
           "stringr",
           "data.table",
           "RMySQL",
           "jsonlite",
           "readr",
           "dplyr",
           "versions",
           "memisc")

if( any(!pCRAN %in% rownames(installed.packages())) ){
  install.packages(pCRAN[!pCRAN %in% rownames(installed.packages())])
}

if(!require(rCharts)) install_github('rCharts', 'ramnathv')

#Load required libraries
packages <- c(pBIOC, pCRAN)
for (ii in 1:length(packages)) {
  require(as.character(packages[ii]), character.only=TRUE)
}

# if memisc fails for some reason on CRAN, like the package is just updated online but CRAN still points to the old package which is not available anymore, then you can install through github:
#devtools::install_github("melff/memisc",subdir="pkg")
my.paths.all <- .libPaths()
my.paths.clean <- NULL
for (mm in 1:length(my.paths.all)) {
  cat(paste0(mm,"/", length(my.paths.all), ": Checking in ", my.paths.all[mm], "\n"))
  if (any(grepl("sjPlot", installed.packages(lib=my.paths.all[mm])[,1]))) {
#    cat(paste0("       *** sjPlot found in ", my.paths.all[mm], " ***\n"))
    cat(paste0("       *** sjPlot found, v ", 
               installed.versions("sjPlot", lib=my.paths.all[mm]),
               " ***\n"))
    my.paths.clean <- c(my.paths.clean, my.paths.all[mm])
  } else {
    cat(paste0("       (none found)\n"))
  }
}
for (my.path in my.paths.clean) {
  cat(paste0("Checking in ", my.path, "\n"))
   if (installed.versions("sjPlot", lib=my.path) != "1.8.4") {
    cat(paste0("       Different sjPlot version than 1.8.4: ",
               installed.versions("sjPlot", lib=my.path), " \n"))
   # Install a secific version of some package, like sjPlot 0.8.4
   packageurl <- "https://cran.r-project.org/src/contrib/Archive/sjPlot/sjPlot_1.8.4.tar.gz"
   install.packages(packageurl, repos=NULL, type="source")  
   } else {
    cat(paste0("       sjPlot v: ", installed.versions("sjPlot", lib=my.path), " \n"))
   }
}
```

# Load data from Rda (if available)

```{r Load data from Rda (if available), echo=TRUE}
my.rda <- "mySession.Rda"

# load it from disk (if present on disk)
if (file.exists(file.path(getwd(), my.rda))) {
  ## ----loadData------------------------------------------------------------
  load(file=file.path(getwd(), my.rda))
}
```

# Fetch data from the trasplantaments db into a .csv file on disk

```{r Fetch data from the trasplantaments db into a .csv file on disk, echo=T}
aID <- "TikiTrackerDB" # Analysis ID

# If your tiki is not under localhost, adapt the path below for my.file
#my.file <- "http://localhost/12.x/tiki-ajax_services.php?controller=tracker&action=export_items&trackerId=1&encoding=UTF-8&separator=%2C&delimitorL=%22&delimitorR=%22&CR=%25%25%25&listfields[]=9&listfields[]=10&listfields[]=11&recordsMax=-1"
my.trackerId <- 1
my.domain <- "http://localhost/12.x/"
my.file <- paste0(my.domain, "tiki-ajax_services.php?controller=tracker&action=export_items&trackerId=", my.trackerId,"&encoding=UTF-8&separator=%2C&delimitorL=%22&delimitorR=%22&CR=%25%25%25&recordsMax=-1")


# You need to set "Admin > Control Panels > Security > HTTP Basic Authentication" (login_http_basic) to "Always"" or "SSL Only" 
# Then create a user with the following credentials in your Tiki
my.c <- GET(my.file, authenticate("exporter", "12345"))
# my.c stands for my connection. It has a list of 10 elements.
names(my.c)
# [1] "url"         "status_code" "headers"     "all_headers" "cookies"     "content"     "date"       
# [8] "times"       "request"     "handle" 

str(content(my.c))

# Fetch a guess for the encoding of the data that came from Tiki. It should be UTS-8 in most cases, but you never know (it depends on the configuration set at the local tiki instance)
my.c.encoding <- stringi::stri_enc_detect(httr::content(my.c, "raw"))
my.c.encoding
my.c.encoding <- my.c.encoding[[1]]$Encoding[1]
my.c.encoding
#my.df <- content(my.c, "text", encoding = my.c.encoding)

# Fetch content in binari form and save to plain text file on disk
bin <- httr::content(my.c, "raw", encoding="UTF-8")
my.base.filename <- paste0("trk", my.trackerId,"_", format(Sys.Date(), "%y%m%d"))
writeBin(bin, file.path(getwd(), dataRelDir, paste0(my.base.filename, "_my.df.dirty.csv")))
```

## massage and cleanup the dataset
We tried applying an "apply" function to the whole data frame just for the sake of practising with the apply function itself, since the gsub would do it on the 2nd column, which is the only one selfnumbered which carries this html markup to show the "#" sign in front of it, as defined in the Tracker Field definition. However, since the apply converts the dataframe into a matrix, and classes of the data.frme variables get lost, we avoid it, and we use a for loop and replace on site

```{r massage and cleanup the dataset, echo=TRUE}
Sys.setlocale('LC_ALL','C') # Needed to avoid this warning message: "input string 90 is invalid in this locale", etc. Adn this line had this code: "1=S\xed\" (meaning "1=SÃ­").

## This command with iconv after the csv is read into R will fail for colnames (it produces NA). 
#  iconv(colnames(my.df), to='ASCII//TRANSLIT')
## Therefore, solve this issue with a system call to unnaccent (reuing iconv in the backend)
#  sudo apt-get install unaccent
# unaccent UTF-8 < file > file.unaccented
my.df.file.dirty <- file.path(getwd(), dataRelDir, paste0(my.base.filename, "_my.df.dirty.csv"))
my.df.file.clean <- file.path(getwd(), dataRelDir, paste0(my.base.filename, "_my.df.clean.csv"))
system(paste0("unaccent UTF-8 < ", my.df.file.dirty, " > ", my.df.file.clean))
# Replace all html tags, such as "<span class='formunit'>#</span>" with sed at system level
# sed 's/FINDSTRING/REPLACESTRING/g' $fl.old > $fl
sed.command <- paste0("sed -i -e 's/<[^>]*>//g' ", my.df.file.clean)
system(sed.command)
sed.command <- paste0("sed -i -e 's/%%%//g' ", my.df.file.clean)
system(sed.command)
sed.command <- paste0("sed -i -e 's/\t//g' ", my.df.file.clean)
system(sed.command)
sed.command <- paste0("sed -i -e 's/?nbsp;//g' ", my.df.file.clean)
system(sed.command)



# Read the csv file
#my.df <- fread(file.path(getwd(), dataRelDir, my.tracker.file), stringsAsFactors=FALSE, data.table=F)
# Replace data.table::fread efficient function with readr::read_csv, which self recognizes data types, while standard read.csv or fread does not. 
my.df <- readr::read_csv(my.df.file.clean)
#str(my.df)
head(my.df[,1:10])

#class(gsub("<span class='formunit'>#</span>", "", my.df[,2], fixed=T))
# Clean col 2 ("#Id -- 1", self numbered column in Tiki with this annoying span html class)
my.df[,"#Id -- 1"] <- gsub("<span class='formunit'>#</span>", "", my.df[,"#Id -- 1"], fixed=T)
#my.df[,2] <- str_replace_all(my.df[,2], "<span class='formunit'>#</span>", "")
#colnames(my.df)
#iconv(colnames(my.df), to='ASCII//TRANSLIT')

#my.df.c <- apply(my.df, 2, gsub, pattern="<span class='formunit'>#</span>", replacement="", fixed=T)

# Convert the tbl_df class from readr package into a standard data.frame class to avoid some issues later on of functions for other packages not expecting to work with such tbl_df class
my.df.c <- as.data.frame(my.df)
my.df.c[,1:10]
str(my.df.c)
# Convert back the object to a data.frame
#my.df.c <- data.frame(my.df.c, stringsAsFactors = FALSE) #
#str(my.df.c)

# Search for data for fieldId 549 in the my.df (Dataframe with data)
#my.df[,grep("549", colnames(my.df.c))]
#colnames(my.df)[grep("549", colnames(my.df.c))]

```

# Fetch Mysql DB Table for Tracker fields

```{r Fetch Mysql DB Table for Tracker fields}
myTrackerId <- 1
myMySQLUser <- "exporter"
myMySQLPw   <- "12345"
myTikiDb    <- "tiki12svn_trasplantaments"
myTikiTable <- "tiki_tracker_fields"
# connect to local MySQL database (host='localhost' by default)
con = dbConnect(RMySQL::MySQL(), myTikiDb, username=myMySQLUser, password=myMySQLPw)
summary(con)
dbGetInfo(con)
dbListResults(con)
dbGetQuery(con, "SET NAMES utf8")
dbGetQuery(con, 'set character set utf8')
dbGetQuery(con, "SHOW VARIABLES LIKE 'character_set_%'")
db.tables <- dbListTables(con)
head(db.tables)
#tmp <- sprintf("SELECT * FROM name WHERE lname = %s", "O'Reilly")
#dbEscapeStrings(con, tmp)

my.t = dbReadTable(con, myTikiTable) # All fields from all trackers
head(my.t, 4)
dim(my.t)
# [1] 274  23

my.tfd <- base::subset(my.t, trackerId == myTrackerId) # My Tracker Fields Definition

# Save dataset to disk as csv
my.tfd.file.dirty <- file.path(getwd(), dataRelDir, paste0(my.base.filename, "_my.tfd.dirty.csv"))
write_csv(my.tfd, my.tfd.file.dirty)

# Clean accents out of the Tracker Definition table data with "unaccent"" also here, in an equivalent way to the conversion done for the my.df dataset.
# unaccent UTF-8 < file > file.unaccented
my.tfd.file.clean <- file.path(getwd(), dataRelDir, paste0(my.base.filename, "_my.tfd.clean.csv"))
system(paste0("unaccent UTF-8 < ", my.tfd.file.dirty, " > ", my.tfd.file.clean))

# Read the csv file
#my.df <- fread(file.path(getwd(), dataRelDir, my.tracker.file), stringsAsFactors=FALSE, data.table=F)
# Replace data.table::fread efficient function with readr::read_csv, which self recognizes data types, while standard read.csv or fread does not. 
#my.tfd <- readr::read_csv(my.tfd.file.clean)
#my.tfd <- as.data.frame(my.tfd)
#dim(my.tfd)
#head(my.tfd)
#str(my.tfd)

# You might want to Check that there are not duplicataed field definitions
#my.t.fieldIds = dbGetQuery(con, paste0("SELECT DISTINCT fieldId FROM ", myTikiTable))

# Disconnect from the MySQL connection
dbDisconnect(con)
```

## Clean the Tracker field definition also for weirdnesses

```{r Clean the Tracker field definition also for weirdnesses}

# With a simple gsub over columns options
#issue.idx <- grep("\\u00", my.tfd[,"options"], fixed=T)
#my.tfd[issue.idx,"options"]
##grep("<U+00E1>", my.tfd[,"name"], fixed=T)
my.tfd[,"options"] <- gsub("S\\u00cd", "Si", my.tfd[,"options"], fixed=T)
my.tfd[,"options"] <- gsub("S\\u00ed", "Si", my.tfd[,"options"], fixed=T)
#issue.idx <- grep("Tabaco", my.tfd[,"name"], fixed=T)
#my.tfd[issue.idx,]

# Pending ToDo: handle properly the Multiple option fields
# --------
#multopt.idx <- grep("\"inputtype\":\"m\"", my.tfd[,"options"], fixed=T)
#my.tfd[multopt.idx,]
# ---------

my.tfd[,"options"] <- gsub("\\u00f3", "o", my.tfd[,"options"], fixed=T)
my.tfd[,"options"] <- gsub("\\u00e1", "a", my.tfd[,"options"], fixed=T)
my.tfd[,"options"] <- gsub("\\u00fa", "u", my.tfd[,"options"], fixed=T)
my.tfd[,"options"] <- gsub("\\u00f1", "ny", my.tfd[,"options"], fixed=T)
my.tfd[,"options"] <- gsub("\\u00e9", "e", my.tfd[,"options"], fixed=T)
my.tfd[,"options"] <- gsub("\\u00ed", "i", my.tfd[,"options"], fixed=T)

#issue.idx <- grep("\303", my.tfd[,"name"], fixed=T)
#my.tfd[issue.idx,"name"]
my.tfd[,"name"] <- gsub("\303\241", "a", my.tfd[,"name"], fixed=T) # "Ã¡" for "a" # <U+00E1>
my.tfd[,"name"] <- gsub("\303\255", "i", my.tfd[,"name"], fixed=T) # "Ã­" for "i" # <U+00E1>
my.tfd[,"name"] <- gsub("\303\263", "o", my.tfd[,"name"], fixed=T) # "Ã³" for "o" # <U+00E1>
my.tfd[,"name"] <- gsub("\303\223", "O", my.tfd[,"name"], fixed=T) # "Ã" for "O" # <U+00E1>
my.tfd[,"name"] <- gsub("\303", "", my.tfd[,"name"], fixed=T) # "" for "" # <U+00E1>

# Same cleaning for Options
my.tfd[,"options"] <- gsub("\303\241", "a", my.tfd[,"options"], fixed=T) # "Ã¡" for "a" # <U+00E1>
my.tfd[,"options"] <- gsub("\303\255", "i", my.tfd[,"options"], fixed=T) # "Ã­" for "i" # <U+00E1>
my.tfd[,"options"] <- gsub("\303\263", "o", my.tfd[,"options"], fixed=T) # "Ã³" for "o" # <U+00E1>
my.tfd[,"options"] <- gsub("\303\223", "O", my.tfd[,"options"], fixed=T) # "Ã" for "O" # <U+00E1>
my.tfd[,"options"] <- gsub("\303", "", my.tfd[,"options"], fixed=T) # "" for "" # <U+00E1>

#iconv(my.tfd[,"options"], to='ASCII//TRANSLIT')
#iconv(my.tfd[,"name"], to='ASCII//TRANSLIT')

#colnames(my.tfd)
#my.tfd[grep("438", my.tfd$"fieldId"),]
#my.tfd[grep("51$", my.tfd$"fieldId"),]
#my.tfd[grep("\341", my.tfd$"name"),]

# "Processing fieldId"

#my.tfd <- apply(my.tfd, 2, gsub, pattern="S\\u00cd", replacement="Si", fixed=T)
#my.tfd <- apply(my.tfd, 2, gsub, pattern="S\\u00ed", replacement="Si", fixed=T)
```

# Some tests (before we go for real)

## Test the display of a radio button field

```{r Test the display of a radio button field}
check.one.rb.field <- F # TRUE # FALSE
if (check.one.rb.field) {
    # Test displaying as dataframe some json-encoded data from a radio button field definition
    
    # Display with row from the my.tt df object contains the values for the definition of fieldId 9 (Sexo -- 9)
    #which(my.tfd$fieldId==9)
    # [1] 135
    #my.tfd[which(my.tfd$fieldId==9),"options"]
    # [1] "{\"options\":[\"0=Mujer\",\"1=Varon\",\"99=ns/nc\"]}"
    #table(as.numeric(my.tfd$fieldId)==9)
    #class(my.tfd$fieldId)
    
    #which(my.tfd$fieldId==549)
    # [1] 8
    #my.tfd[which(my.tfd$fieldId==549),"options"]
    # "{\"options\":[\"0=NO\",\"1=Si\",\"99=NS\\/NC\"]}"
    #table(as.numeric(my.tfd$fieldId)==549)
    #class(my.tfd$fieldId)

  # Test for the missing info in Dates
    #which(my.tfd$fieldId==8)
    # [1] 118
    #my.tfd[which(my.tfd$fieldId==8),"options"]
    # [1] "{\"datetime\":\"d\",\"startyear\":\"1900\",\"endyear\":\"2016\",\"blankdate\":\"blank\"}"
    #table(as.numeric(my.tfd$fieldId)==118)
    #class(my.tfd$fieldId)
    my.options.test <- unlist(fromJSON(as.character(my.tfd[which(as.numeric(my.tfd$fieldId)==8),"options"])))
    my.op.tmp.test <- unlist(str_split(my.options.test, "="))
    
    #head(my.df[,1:10])
    #length(colnames(my.df))
    #[1] 274
    # my.tfd[8,]
    #str(my.df[,"Sexo -- 9"])
    
    #my.field.colname <- "Sexo -- 9" # As a Column name of my.df
    #my.field.colname <- "Tabaco -- 19" # As a Column name of my.df
    my.field.colname.test <- "AnoxToxMet. Hidroelectro Tipo -- 549" # As a Column name of my.df
    my.field.name.test <- unlist(str_split(my.field.colname.test, " -- "))[1]
    my.field.id.test <- unlist(str_split(my.field.colname.test, " -- "))[2]
    my.field.data.test <- as.data.frame(my.df.c[,my.field.colname.test])[,1]
    
    #Recode something like 
                      # "0"     "Mujer" "1"     "Varon" "99"    "ns/nc"
                      # into something like:
                      # "Mujer" = 0, "Varon" = 1, "ns/nc" = 99
    cc <- 0 # loop counter
    my.options.test <- NULL
    my.op.tmp.number.test <- NULL
    my.op.tmp.label.test <- NULL
    # We generate two clean vectors with the information of the numbers (option values in the form)
    # and the corresponding labels shown in the form, for further merging of the information 
    # in the memisc::as.item function.
    for (ii in seq(1, length(my.op.tmp.test), by=2)) {
      cc <- cc+1
      my.op.tmp.number.test[cc] <- my.op.tmp.test[ii] 
      my.op.tmp.label.test[cc]  <- my.op.tmp.test[ii+1]
    }
    
    #my.op.tmp.number # Clea vector of numbers (options in the form)
    #my.op.tmp.label # Clean vector of labels corresponding to the previous options
    
    # If we were to do it by hand we would do it like this:
    #memisc::labels(my.field.data) <- c("Mujer" = 0,
    #                           "Varon" = 1,
    #                           "ns/nc" = 99)
    # However, with standard "assign" or "factor" or equivalent functions, it doesn't work:
    #memisc::labels(my.field.data) <- c("\"Mujer\"" = 0,  "\"Varon\"" = 1,  "\"ns/nc\"" = 99)
    
    # Therefore we need to use the memisc:as.item function to properly merge all the required info in place
    my.field.labels.test <- memisc::as.item(my.field.data.test, 
                          labels=structure(my.op.tmp.number.test, 
                                           names=my.op.tmp.label.test),
                          missing.values=99,
                          annotation = c(
                            description=my.field.name.test
                            )
                          )
    memisc::labels(my.field.labels.test)
    
    my.labels.df.test <- data.frame(as.numeric(my.op.tmp.number.test),
                               as.character(my.op.tmp.label.test), stringsAsFactors=FALSE) 
    colnames(my.labels.df.test) <- c("value", "label")
    df1.test <- data.frame(my.field.data.test)
    colnames(df1.test) <-"value"
    df2.test <- my.labels.df.test
     merged.df.test <- left_join(df1.test, df2.test, by = "value")

        # SJMISC LABELS
    # -----------------
    # If there are more labels than levels of values, avoid the error.
    if (length(table(my.field.labels.test)) != length(table(memisc::labels(my.field.labels.test)))) {
        my.field.data.labels.sjmisc.test <- try(set_labels(my.field.data.test,
                                                      merged.df.test$label)    , TRUE)
                if (grepl("rror", my.field.data.labels.sjmisc.test, fixed=T)) {
                          my.field.data.labels.sjmisc.test <- cbind(my.field.data.labels.sjmisc.test, t(df1))
                  }

    } else {
        # Set also labels in the format expected by sjmisc with set_labels()
        my.field.data.labels.sjmisc.test <- set_labels(my.field.data.test,
                                                  memisc::labels(my.field.labels.test),
                                                  force.labels = F, force.values = T)
    }
    #view_df(as.data.frame(my.field.labels.test))
    my.field.data2.test <- set_labels(my.field.data.test, memisc::labels(my.field.labels.test))
    get_labels(my.field.data2.test, include.values = T,  include.non.labelled = TRUE)
    #view_df(data.frame(my.field.data2.test))
    #my.field.data3 <- set_labels(my.field.data.test, memisc::labels(my.field.labels.test), 
    #                             force.labels = TRUE, force.values = FALSE)
    #get_labels(my.field.data3.test, include.values = T,  include.non.labelled = TRUE)
    #view_df(data.frame(my.field.data3.test))

}

```


## Test function view_df to attempt to tweak it for date fields

```{r Test function view_df to attempt to tweak it for date fields}

view_df2 <- function (x, weightBy = NULL, file = NULL, alternateRowColors = TRUE, 
    showID = TRUE, showType = FALSE, showValues = TRUE, showValueLabels = TRUE, 
    showFreq = FALSE, showPerc = FALSE, showWtdFreq = FALSE, 
    showWtdPerc = FALSE, showNA = FALSE, sortByName = FALSE, 
    breakVariableNamesAt = 50, encoding = NULL, hideProgressBar = FALSE, 
    CSS = NULL, useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE) 
{
    encoding <- get.encoding(encoding, x)
    if (!is.data.frame(x)) 
        stop("Parameter needs to be a data frame!", call. = FALSE)
    df.var <- sjmisc::get_label(x)
    df.val <- sjmisc::get_labels(x)
    colcnt <- ncol(x)
    id <- 1:colcnt
    if (sortByName) 
        id <- id[order(colnames(x))]
    tag.table <- "table"
    tag.thead <- "thead"
    tag.tdata <- "tdata"
    tag.arc <- "arc"
    css.table <- "border-collapse:collapse; border:none;"
    css.thead <- "border-bottom:double; font-style:italic; font-weight:normal; padding:0.2cm; text-align:left; vertical-align:top;"
    css.tdata <- "padding:0.2cm; text-align:left; vertical-align:top;"
    css.arc <- "background-color:#eaeaea"
    if (!is.null(CSS)) {
        if (!is.null(CSS[["css.table"]])) 
            css.table <- ifelse(substring(CSS[["css.table"]], 
                1, 1) == "+", paste0(css.table, substring(CSS[["css.table"]], 
                2)), CSS[["css.table"]])
        if (!is.null(CSS[["css.thead"]])) 
            css.thead <- ifelse(substring(CSS[["css.thead"]], 
                1, 1) == "+", paste0(css.thead, substring(CSS[["css.thead"]], 
                2)), CSS[["css.thead"]])
        if (!is.null(CSS[["css.tdata"]])) 
            css.tdata <- ifelse(substring(CSS[["css.tdata"]], 
                1, 1) == "+", paste0(css.tdata, substring(CSS[["css.tdata"]], 
                2)), CSS[["css.tdata"]])
        if (!is.null(CSS[["css.arc"]])) 
            css.arc <- ifelse(substring(CSS[["css.arc"]], 1, 
                1) == "+", paste0(css.arc, substring(CSS[["css.arc"]], 
                2)), CSS[["css.arc"]])
    }
    page.style <- sprintf("<style>\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>", 
        tag.table, css.table, tag.thead, css.thead, tag.tdata, 
        css.tdata, tag.arc, css.arc)
    toWrite <- sprintf("<html>\n<head>\n<meta http-equiv=\"Content-type\" content=\"text/html;charset=%s\">\n%s\n</head>\n<body>\n", 
        encoding, page.style)
    page.content <- "<table>"
    page.content <- paste0(page.content, "  <tr>\n    ")
    if (showID) 
        page.content <- paste0(page.content, "<th class=\"thead\">ID</th>")
    page.content <- paste0(page.content, "<th class=\"thead\">Name</th>")
    if (showType) 
        page.content <- paste0(page.content, "<th class=\"thead\">Type</th>")
    page.content <- paste0(page.content, "<th class=\"thead\">Label</th>")
    if (showNA) 
        page.content <- paste0(page.content, "<th class=\"thead\">missings</th>")
    if (showValues) 
        page.content <- paste0(page.content, "<th class=\"thead\">Values</th>")
    if (showValueLabels) 
        page.content <- paste0(page.content, "<th class=\"thead\">Value Labels</th>")
    if (showFreq) 
        page.content <- paste0(page.content, "<th class=\"thead\">Freq.</th>")
    if (showPerc) 
        page.content <- paste0(page.content, "<th class=\"thead\">%</th>")
    if (showWtdFreq) 
        page.content <- paste0(page.content, "<th class=\"thead\">weighted Freq.</th>")
    if (showWtdPerc) 
        page.content <- paste0(page.content, "<th class=\"thead\">weighted %</th>")
    page.content <- paste0(page.content, "\n  </tr>\n")
    if (!hideProgressBar) 
        pb <- utils::txtProgressBar(min = 0, max = colcnt, style = 3)
    for (ccnt in 1:colcnt) {
        index <- id[ccnt]
        arcstring <- ""
        if (alternateRowColors) 
            arcstring <- ifelse(sjmisc::is_even(ccnt), " arc", 
                "")
        page.content <- paste0(page.content, "  <tr>\n")
        if (showID) 
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%i</td>\n", 
                arcstring, index))
        page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
            arcstring, colnames(x)[index]))
        if (showType) {
            vartype <- get.vartype(x[[index]])
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, vartype))
        }
        if (index <= length(df.var)) {
            varlab <- df.var[index]
            if (!is.null(breakVariableNamesAt)) {
                varlab <- sjmisc::word_wrap(varlab, breakVariableNamesAt, 
                  "<br>")
            }
        }
        else {
            varlab <- "<NA>"
        }
        page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
            arcstring, varlab))
        if (showNA) {
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%i (%.2f%%)</td>\n", 
                arcstring, sum(is.na(x[[index]]), na.rm = T), 
                100 * sum(is.na(x[[index]]), na.rm = T)/nrow(x)))
        }
        if (showValues) {
            valstring <- c("")
            if (index <= ncol(x)) {
                vals <- sjmisc::get_values(x[[index]])
                if (!is.null(vals)) {
                  for (i in 1:length(vals)) {
                    valstring <- paste0(valstring, vals[i])
                    if (i < length(vals)) 
                      valstring <- paste0(valstring, "<br>")
                  }
                }
            }
            else {
                valstring <- "<NA>"
            }
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, valstring))
        }
        if (showValueLabels) {
            valstring <- c("")
            if (index <= length(df.val)) {
                vals <- df.val[[index]]
                if (!is.null(vals)) {
                  for (i in 1:length(vals)) {
                    valstring <- paste0(valstring, vals[i])
                    if (i < length(vals)) 
                      valstring <- paste0(valstring, "<br>")
                  }
                }
            }
            else {
                valstring <- "<NA>"
            }
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, valstring))
        }
        if (showFreq) {
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, frq.value(index, x, df.val)))
        }
        if (showPerc) {
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, prc.value(index, x, df.val)))
        }
        if (showWtdFreq && !is.null(weightBy)) {
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, frq.value(index, x, df.val, weightBy)))
        }
        if (showPerc && !is.null(weightBy)) {
            page.content <- paste0(page.content, sprintf("    <td class=\"tdata%s\">%s</td>\n", 
                arcstring, prc.value(index, x, df.val, weightBy)))
        }
        if (!hideProgressBar) 
            utils::setTxtProgressBar(pb, ccnt)
        page.content <- paste0(page.content, "  </tr>\n")
    }
    if (!hideProgressBar) 
        close(pb)
    page.content <- paste(page.content, "</table>", sep = "\n")
    toWrite <- paste0(toWrite, sprintf("%s\n</body></html>", 
        page.content))
    knitr <- page.content
    knitr <- gsub("class=", "style=", knitr, fixed = TRUE, useBytes = TRUE)
    knitr <- gsub("<table", sprintf("<table style=\"%s\"", css.table), 
        knitr, fixed = TRUE, useBytes = TRUE)
    knitr <- gsub(tag.tdata, css.tdata, knitr, fixed = TRUE, 
        useBytes = TRUE)
    knitr <- gsub(tag.thead, css.thead, knitr, fixed = TRUE, 
        useBytes = TRUE)
    knitr <- gsub(tag.arc, css.arc, knitr, fixed = TRUE, useBytes = TRUE)
    if (remove.spaces) {
        knitr <- sju.rmspc(knitr)
        toWrite <- sju.rmspc(toWrite)
        page.content <- sju.rmspc(page.content)
    }
    out.html.table(no.output, file, knitr, toWrite, useViewer)
    invisible(structure(class = c("sjTable", "view_df"), list(page.style = page.style, 
        page.content = page.content, output.complete = toWrite, 
        knitr = knitr)))
}
```

## Test the display of date fields

```{r Test the display of date fields}
check.one.date.field <- F # TRUE # FALSE
if (check.one.date.field) {
    # Test displaying as dataframe some json-encoded data from a date button field definition
    
    # Test for the missing info in Dates
    my.date.test.field <- 8
    my.date.test.field.row <- which(my.tfd$fieldId==my.date.test.field)
    # [1] 118
    my.tfd[which(my.tfd$fieldId==my.date.test.field),"options"]
    #[1] "{\"datetime\":\"d\",\"startyear\":\"1900\",\"endyear\":\"2016\",\"blankdate\":\"blank\"}"
    #table(as.numeric(my.tfd$fieldId)==my.date.test.field)
    #class(my.tfd$fieldId)
    my.options.test <- unlist(fromJSON(as.character(my.tfd[which(as.numeric(my.tfd$fieldId) ==
                                                                   my.date.test.field),"options"])))
    my.op.tmp.test <- unlist(str_split(my.options.test, "="))
    
    #head(my.df[,1:10])
    #length(colnames(my.df))
    #[1] 274
    my.tfd[my.date.test.field.row,]
    #str(my.df[,"Sexo -- 9"])
    
    #my.field.colname <- "Sexo -- 9" # As a Column name of my.df
    #my.field.colname <- "Tabaco -- 19" # As a Column name of my.df
    my.field.name.test <- my.tfd[which(my.tfd$fieldId==my.date.test.field),"name"]
    my.field.id.test <- my.date.test.field
    my.field.colname.test <- paste0(my.field.name.test , " -- ", my.field.id.test) # As a Column name of my.df
    my.field.data.test <- as.data.frame(my.df.c[,my.field.colname.test])[,1]
    

    view_df(as.data.frame(my.field.data.test), showType=TRUE)
    view_df2(as.data.frame(my.field.data.test), showType=TRUE)
    view_df(as.data.frame(as.character(my.field.data.test)), showType=TRUE)
    sjt.df(as.data.frame(as.character(my.field.data.test)), showType=TRUE)
    #view_df(data.frame(my.field.data2.test))
    #my.field.data3 <- set_labels(my.field.data.test, memisc::labels(my.field.labels.test), 
    #                             force.labels = TRUE, force.values = FALSE)
    #get_labels(my.field.data3.test, include.values = T,  include.non.labelled = TRUE)
    #view_df(data.frame(my.field.data3.test))

}

```

# Check field types and filter out unwanted fields

```{r Check field types and filter out unwanted fields}

# Have a look at the columns and some of their values of the tracker field definitions (my.tfd)
head(my.tfd)

# > table(my.tfd$type)
# 
#    a    C    d    D    f    h    M math    n    q    R    t    u 
#    1    5   26    1   21   47   13    1   42    1   80   35    1
# Tracker field Codes that contain value=label pairs
#Sys.getlocale()
Sys.setlocale('LC_ALL','C') # Needed to avoid this warning message: "input string 90 is invalid in this locale", etc. Adn this line had this code: "1=S\xed\" (meaning "1=SÃ­").
#my.tfd$options[90]
table(my.tfd[grep("options", my.tfd$options, fixed=TRUE),"type"])
#  D  M  R  d 
#  1 13 80 26 
#
# D: Dropdown with other
# M: Multiselect
# R: Radio button
# d: dropdown
#
# See this page to check their correspondence
# https://dev.tiki.org/Tracker+Field+Types

# Headers will be treated aside of the rest. 
# h: Header
#
# Special handling will be needed also for field type:
# f: Date and Time

```

# Cleanup from TRACKER FIELD DEFINITION (my.tfd)

```{r Cleanup from TRACKER FIELD DEFINITION (my.tfd)}
# FROM TRACKER FIELD DEFINITION (my.tfd)
# --------------------------------------
# We can start by removing them from the my.tfd to be displayed as results. We don't do a standard fixed grep to "h" since that would get also the field type "math". Therefore, we grep with a regular expression for "h" at the beggining of the sentence/value and ending with that character also.
fields.headers.idx <- grep("^h$", my.tfd$type, fixed=FALSE)
#length(fields.headers.idx)
# 47
# Get the fieldId's corresponding to Header type of Field
fields.headers.fieldId <- my.tfd[fields.headers.idx,"fieldId"]
# Remove those from the Tracker definition table (my.tfd)
my.tfd <- my.tfd[-fields.headers.idx,]
#colnames(my.tfd)
#head(my.tfd[order(my.tfd$fieldId, decreasing=FALSE),],10)
```

## Cleanup from FROM TRACKER DATA (my.df.c)

```{r Cleanup from FROM TRACKER DATA (my.df.c)}
# FROM TRACKER DATA (my.df.c)
# ---------------------------
# Remove those fields.headers.fieldId from the Tracker data (my.df.c)
#fields.headers.fieldId
#colnames(my.df.c)
# Get the fieldId numbers from the colnames compound string (e.g. "INTRODUCCION -- 525")
my.df.c.col.fieldId <- as.numeric(str_split_fixed(colnames(my.df.c), " -- ", n=2)[,2])
# Get the column positions of the variables type Header
my.df.c.col.fieldId.h <- my.df.c.col.fieldId %in% fields.headers.fieldId
# Check that the results are the expected, and save that info in a vector for further checking and debugging
my.df.c.colnames.h.old <- colnames(my.df.c)[my.df.c.col.fieldId.h]
#length(my.df.c.colnames.h.old)
my.df.c <- my.df.c[,!my.df.c.col.fieldId.h]
#head(my.df.c[,1:15])
#length(colnames(my.df.c))
# Get rid also of the self-numbered id for the tracker
#colnames(my.df.c)[1:10]
#colnames(my.df.c.new)[1:10]
my.df.c <- my.df.c[,-grep("#Id -- 1", colnames(my.df.c))]
my.df.c <- my.df.c[,-grep("Comentarios -- 3", colnames(my.df.c))]
#colnames(my.df.c.new)[1:10]

# Convert to factor all columns the carry dates
my.df.c.date.fname <- grep("Fecha", colnames(my.df.c), fixed=F, ignore.case = T, value=T)
my.df.c[,my.df.c.date.fname] <- lapply(my.df.c[,my.df.c.date.fname] , factor)

```

## Play with dates (optional)

```{r Play with dates}
play.with.dates <- F # F # T
if (play.with.dates) {
  # A. Dates info from  my.df.c
  my.df.c.date.fname <- grep("Fecha", colnames(my.df.c), fixed=F, ignore.case = T, value=T)
  my.df.c.date.col.idx <- grep("Fecha", colnames(my.df.c), fixed=F, ignore.case = T, value=F)
  my.df.c.date.col.fid <- as.numeric(str_split_fixed(colnames(my.df.c)[my.df.c.date.col.idx], " -- ", n=2)[,2])
  
  for (dd in 1:length(my.df.c.date.col.idx)) {
    # dd <- 1;
    if (length(str_split(as.character(my.df.c[1,my.df.c.date.col.idx[dd]]), "-")[[1]]) > 3) {
      as.Date(my.df.c[,my.df.c.date.col.idx[dd]], format="%Y-%m-%d %H:%M:%S")  
    } else if (length(str_split(as.character(my.df.c[1,my.df.c.date.col.idx[dd]]), "-")[[1]]) == 3){
      as.Date(my.df.c[,my.df.c.date.col.idx[dd]], format="%Y-%m-%d")  
    } else {
      cat(my.df.c[,my.df.c.date.col.idx[dd]])
      cat("\n*** Unclear date format. Please revise your date ***\n")
    }
  }
  
  #view_df(data.frame(my.df.c))
  #md <- my.df.c[1,my.df.c.date.col.idx]
  #md[1:3]
  #class(md[1,3])
  #as.Date(md[1,3], format="%Y-%m-%d %H:%M:%S")-as.Date(md[1,2], format="%Y-%m-%d %H:%M:%S")
  
  # B. Dates info from  my.tfd
  fields.dates.idx <- grep("^f$", my.tfd$type, fixed=FALSE)
  length(fields.dates.idx)
  # 21
  # Get the fieldId's corresponding to date type of Field
  fields.dates.fieldId <- my.tfd[fields.dates.idx,"fieldId"]
  table(fields.dates.fieldId %in% my.df.c.date.col.fid)
}

```

# Get the list of fields TRACKER FIELD DEFINITION (my.tfd) with Options

```{r Get the list of fields TRACKER FIELD DEFINITION (my.tfd) with Options}
# FROM TRACKER FIELD DEFINITION (my.tfd)
# --------------------------------------
#colnames(my.tfd)
#head(my.tfd[order(my.tfd$fieldId, decreasing=FALSE),],10)
# Indexes of the data frame that correspond to fields which contain value:label pairs (as options)
fields.with.options.idx <- grep("options", my.tfd$options, fixed=TRUE)
  #head(my.tfd[fields.with.options.idx,])
  #head(my.tfd[fields.with.options.idx, c("type","options")])
# FieldId's for those cases of tracker fields (fields which contain value:label pairs, as options)
fields.with.options.fieldId <- my.tfd[fields.with.options.idx,"fieldId"]
```

# Loop to add value/label pairs to all variables where needed

```{r Loop to add value/label pairs to all variables where needed}
# Get the column numbers of the variables that contain data that needs to be labelled properly
# Identify the data columns that require value:label pair fixing
#head(my.df.c)

for (ff in 1:length(fields.with.options.fieldId)) {
  #ff <- 43 # f_id 19; ff <- 61; ff <- 1 # f_id 281; ff <- 2 # f_id 280; ff <- 3 # f_id 270...; ff <- 5 # f_id 549 
  # fields.with.options.idx[ff]
  # Report progress
  cat(paste0(" (", ff, "/", length(fields.with.options.fieldId), ")", " Processing fieldId: ", fields.with.options.fieldId[ff], "\n"))

  # Get the options for that field
  my.options <- unlist(fromJSON(as.character(my.tfd[which(as.numeric(my.tfd$fieldId)==as.numeric(fields.with.options.fieldId[ff])),"options"])))
  # Split the options in chunks
  my.op.tmp <- unlist(str_split(my.options, "="))
  
  # Get the field name
  my.tfd[which(my.tfd["fieldId"]==as.numeric(fields.with.options.fieldId[ff])), "name"]
  #head(my.tfd)
  #str(my.tfd)
  my.df.c.col.idx <- grep(paste0("-- ", fields.with.options.fieldId[ff], "$"), colnames(my.df.c), fixed=FALSE)
  
  #my.df.c <- data.frame(my.df.c)
  #my.df.c[,my.df.c.col.idx]
  
  my.field.colname <- colnames(my.df.c)[my.df.c.col.idx] # "Sexo -- 9" # As a Column name of my.df
  my.field.name <- unlist(str_split(my.field.colname, " -- "))[1]
  my.field.id <- unlist(str_split(my.field.colname, " -- "))[2]
  my.field.data <- as.integer(my.df.c[,my.field.colname])

  #Recode something like 
                    # "0"     "Mujer" "1"     "Varon" "99"    "ns/nc"
                    # into something like:
                    # "Mujer" = 0, "Varon" = 1, "ns/nc" = 99
  cc <- 0 # loop counter
  my.options <- NULL
  my.op.tmp.number <- NULL
  my.op.tmp.label <- NULL
  # We generate two clean vectors with the information of the numbers (option values in the form)
  # and the corresponding labels shown in the form, for further merging of the information 
  # in the memisc::as.item function.
  for (ii in seq(1, length(my.op.tmp), by=2)) {
    cc <- cc+1
    my.op.tmp.number[cc] <- my.op.tmp[ii] 
    my.op.tmp.label[cc]  <- my.op.tmp[ii+1]
  }
  
  my.labels.df <- data.frame(as.numeric(my.op.tmp.number),
                             as.character(my.op.tmp.label), stringsAsFactors=FALSE) 
  colnames(my.labels.df) <- c("value", "label")
  
  #In case we have some data in this variable, set the labels for memisc and for sjmisc.
  # Keep in mind that they are set in the different way, and that's why you need to do both things, depending on the extra steps needed, so that you can just call one (memisc) or the other (sjmisc) as needed. 
  if (sum(as.numeric(as.character(my.field.data)), na.rm=T) > 0) {
    # (1) MEMISC LABELS
    # -----------------
    # First, we need to use the memisc:as.item function to properly merge all the required info in place
    my.field.data.labels.memisc <- memisc::as.item(my.field.data, 
                                        labels=structure(my.op.tmp.number, 
                                                         names=my.op.tmp.label),
                                        missing.values=99,
                                        annotation = c(
                                          description=my.field.name
                                          )
                                        )
    # We do not attempt to display html with labels-values since it fails with this label format
    ##view_df(data.frame(my.field.data.labels.memisc))
    ##sjmisc::get_labels(my.field.data.labels.memisc, include.values = T)

    # Check labels
    #memisc::labels(my.field.data.labels.memisc)
    
              
    # (2a) Get a vector of labels as long as the vector of values
    # -----------------
    # Get a vector of labels as long as the vector of values, adn reuse it for sjmisc::set_labels
    df1 <- data.frame(my.field.data)
    colnames(df1) <-"value"
    df2 <- my.labels.df
    #class(df1)
    #class(df2$value)
#    merged.df <- merge(df1, df2, by = intersect(names(df1), names(df2)), all.x=T)
     merged.df <- left_join(df1, df2, by = "value")
   
    # (2b) SJMISC LABELS
    # -----------------
    # If there are more labels than levels of values, avoid the error.
    if (length(table(my.field.data)) != length(table(memisc::labels(my.field.data.labels.memisc)))) {
        cat("\n*** Case (2bA) SJMISC LABELS: A - set_labels(my.field.data, merged.df$label)***\n")
        my.field.data.labels.sjmisc <- try(set_labels(my.field.data,
                                                      merged.df$label)    , TRUE)
        if (grepl("rror", my.field.data.labels.sjmisc, fixed=T)) {
          my.field.data.labels.sjmisc <- gsub(my.field.data.labels.sjmisc,
                                              "\n$", 
                                              paste0(my.field.data.labels.sjmisc,
                                                     "\n",
                                                     "*** caseA ***\n",
                                                     df1, 
                                                     collapse=",")
                                              )
        }
    } else {
        cat("\n*** Case (2bB) SJMISC LABELS: B - set_labels(my.field.data, memisc::labels(my.field.data.labels.memisc) ***\n")
        # Set also labels in the format expected by sjmisc with set_labels()
        my.field.data.labels.sjmisc <- set_labels(my.field.data,
                                                  memisc::labels(my.field.data.labels.memisc),
                                                  force.labels = F, force.values = T)
    }

#     length(my.field.data)
#names(my.field.data)
#     length(labels(my.field.data))
#     length(labels(merged.df$label))
#     names(merged.df$label)
#     length(memisc::labels(my.field.data.labels.memisc))
#     class(my.field.data)
#     class(base::labels(my.field.data.labels.memisc))
#     class(memisc::labels(my.field.data.labels.memisc))
#     
    # Display html with variable and labels-values
    #view_df(data.frame(my.field.data.labels.sjmisc))
    # Check labels
    #sjmisc::get_labels(my.field.data.labels.sjmisc, include.values = T, include.non.labelled = T)
      #memisc::labels(my.field.data.labels.sjmisc)
    
    # (3) SET LABELS in DATA.FRAME VARIABLE
    # -----------------
    # Re-assign to the Dataframe with the clean data (my.df.c) that variable with the labels properly set
    my.df.c[,my.df.c.col.idx] <- my.field.data.labels.sjmisc

      
  # Record on disk an html version of this varaible with labels.
  if (any(grepl("Error", try(view_df(as.data.frame(my.field.data.labels.sjmisc), 
                                   file=file.path(logsRelDir, paste0("view_df_ff", ff,
                                                  "_fieldId", my.field.id,
                                                  "_col", my.df.c.col.idx,
                                                  "_", my.field.name,
                                                  ".html")) ), TRUE), ignore.case = TRUE, fixed=FALSE))) {
    cat(paste0("Error in ff", ff, "_fieldId", my.field.id, "_col", my.df.c.col.idx,
               "_", my.field.name, "\n"))
                                                  }
  
  } # Done setting labels to a variable with data to be labelled


} # Done with this variable (ff - field with options - loop)
 #str(my.df.c)


```

# Convert the tracker data to data.set for package memisc (Optional)

```{r Convert the tracker data to data.set for package memisc}
# Our data is still stored as a matrix.
#class(my.df.c)

# Therefore we need to convert the clean matrix of data, into a data.frame, and convert it to class data.set from package memisc
#my.ds <- as.data.set(data.frame(my.df.c)) 
# Fails with: 
#Error in (function (classes, fdef, mtable)  : 
#  unable to find an inherited method for function 'as.item' for signature '"Date"'
#class(my.ds)
```

# Produce some description out of the data

```{r Produce some description out of the data}
require(sjmisc)
require(sjPlot)

# Test col by col to see where the problem is
for (cc in 1:length(colnames(my.df.c))) {
    view_df(data.frame(my.df.c[,colnames(my.df.c)[cc]]), 
            file=file.path(logsRelDir, paste0(my.base.filename,"_view_df_col", 
                                                 cc,".html")),
            showFreq = TRUE, showPerc = TRUE, encoding = "UTF-8", showType=TRUE)
}
 
view_df(data.frame(my.df.c), 
        file=file.path(resultsRelDir, paste0(my.base.filename,"_view_df.html")),
        showFreq = TRUE, showPerc = TRUE, encoding = "UTF-8", showType=TRUE)
#view_df(data.frame(my.df.c), showFreq = TRUE, showPerc = TRUE) #  # As before, but with frequencies and percentages (as a "codebook")
sjt.df(as.data.frame(my.df.c),
       file=file.path(resultsRelDir, paste0(my.base.filename,"_sjt.df.html")),
       showType=TRUE)

#view_df(data.frame(my.ds), file=paste0("view_df_my.ds", ".html"))
#view_df(data.frame(my.ds), showFreq = TRUE, showPerc = TRUE) #  # As before, but with frequencies and percentages (as a "codebook")

#sjt.frq (data.frame(my.df.c)[,10]) # For one variable, such as "Sexo -- 9", which is #10 here.

```

# Tweak data and labels through GUI (Optional)


```{r Tweak data and labels through GUI (Optional)}
#require(Rz)
#Rz()

```

# Create Codebook (Optional)

```{r Create Codebook (optional)}
# CodeBooks
# ----------
# Add here the commands to create a codebook from memisc, in case we need it. But since we don't, it seems, then we skip this part, for the time being.


```

# Some ways to make descriptive statistics (Optional)

```{r Some ways to make descriptive statistics}
# See http://r-es.org/7jornadasR/ponencias/jose_ignacio_casas.pdf (Slide 21 onwards)
#dim(my.t.fieldIds)

#description(my.df[,1:10])
# Try some packaages for a basic descriptive statistics out of some data set
#
# compareGroups: 
# https://cran.r-project.org/web/packages/compareGroups/vignettes/compareGroups_vignette.pdf
#
# Describer (+ dplyr + knitr +reshape2): https://github.com/paulhendricks/describer
#
# Check vignettes of DescTools: http://www.r-pkg.org/pkg/DescTools
# https://cran.r-project.org/web/packages/DescTools/vignettes/DescToolsCompanion.pdf
# https://cran.r-project.org/web/packages/DescTools/vignettes/TablesInR.pdf
#
# memisc
# http://www.elff.eu/memisc/gentab/
# http://www.elff.eu/memisc/ftable-matrix/


# Handling of values and labels:
# http://www.elff.eu/memisc/items/
## SEE: http://www.elff.eu/memisc/items/#codebooks-of-survey-items


#install.packages("sjPlot")
#install.packages("sjmisc")
#install.packages("stringr")

# "Quantitative Discourse Analysis Package: Bridging the Gap Between Qualitative Data and Quantitative Analysis"
#install.packages("qdap")
#library(qdap)

### EXAMPLE with pre-set data frame by hand
# marca<-c("opel","renault","renault")
# model<-c("corsa","laguna","modus")
# cilindrada<-c(1.2,1.9,1.5)
# color<-c("blanc","vermell","violeta")
# cotxes<-data.frame(marca,model,cilindrada,color)
# cotxes
# init default theme for plots
#sjp.setTheme(geom.label.size = 2.5, axis.title.size = .9, axis.textsize = .9)
#sjp.frq(cotxes$marca)
#str(my.df)
#sjp.frq(my.df[,1]) # this fails for unknown reason
#my.df <- set_labels(my.df, c(str_split(colnames(my.df), "\\.")[[1]][1],
#                                 str_split(colnames(my.df), "\\.")[[2]][1],
#                                 str_split(colnames(my.df), "\\.")[[3]][1]))
```

# Store objects into an Rda
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r Store objects into an Rda, echo=FALSE}
save(my.c,
     my.df,
     my.df.c,
     my.tfd,
     my.tracker.file,
     my.ds,
     file=my.rda)
```

# Stored session info

```{r Stored session info, echo=TRUE}
###################################################
# Store session info (package versions, etc) in the logs folder
###################################################
sink(file.path(logsRelDir, paste0("log_", format(Sys.Date(), format="%y%m%d"), "_", aID, ".txt")))
cat("Sys.info() : \n")
cat("--------------------\n")
data.frame(Sys.info())
if (exists("biocValid")) {
  cat("\n\nbiocValid() : \n")
  cat("--------------------\n")
  biocValid()
} else { # Only show sessionInfo() if no biocValid() is found since it's already included in it.
  cat("\n\nsessionInfo() : \n")
  cat("--------------------\n")
  sessionInfo()
}
sink()

```

