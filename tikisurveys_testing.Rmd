---
title: "Tiki surveys Testing"
author: "Xavier de Pedro Puente"
date: "25/01/2016"
output: html_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

Interesting Slides from a presentation in VII Jornades de Usuarios de R (R-es)
See Presentation from:
http://files.meetup.com/1781511/useR%20Vignette%20-%20Accessing%20Databases%20from%20R%20-%2020110504.pdf

## Install packages

```{r Install packages, echo=FALSE}
#############################
# Package dependencies
#############################
## ----librerias, eval=TRUE------------------------------------------------
## Bioconductor
installifnot <- function (pckgName){
  if(!(require(pckgName, character.only=TRUE))){
    source("http://Bioconductor.org/biocLite.R")
    biocLite(pckgName)
  }
}
# Names of packages to be installed from BIOCONDUCTOR if not present yet in this machine
pBIOC <- NULL

if( any(!pBIOC %in% rownames(installed.packages())) ){
  installifnot(pBIOC[!pBIOC %in% rownames(installed.packages())])
}

# Names of packages to be installed from CRAN if not present yet in this machine
pCRAN <- c("devtools",
           "sjPlot",
           "sjmisc",
           "ggplot2",
           "httr",
           "stringi",
           "stringr",
           "data.table",
           "RMySQL",
           "jsonlite",
           "memisc")

if( any(!pCRAN %in% rownames(installed.packages())) ){
  install.packages(pCRAN[!pCRAN %in% rownames(installed.packages())])
}

if(!require(rCharts)) install_github('rCharts', 'ramnathv')

#Load required libraries
packages <- c(pBIOC, pCRAN)
for (ii in 1:length(packages)) {
  require(as.character(packages[ii]), character.only=TRUE)
}

# if memisc fails for some reason on CRAN, like the package is just updated online but CRAN still points to the old package which is not available anymore, then you can install through github:
#devtools::install_github("melff/memisc",subdir="pkg")
```

## Load data from Rda (if available)

```{r Load data from Rda (if available), echo=TRUE}
my.rda <- "mySession.Rda"

# load it from disk (if present on disk)
if (file.exists(file.path(getwd(), my.rda))) {
  ## ----loadData------------------------------------------------------------
  load(file=file.path(getwd(), my.rda))
}
```

## Fetch data from the trasplantaments db

```{r Fetch data from the trasplantaments db, echo=T}
aID <- "TikiTrackerDB" # Analysis ID

# If your tiki is not under localhost, adapt the path below for my.file
#my.file <- "http://localhost/12.x/tiki-ajax_services.php?controller=tracker&action=export_items&trackerId=1&encoding=UTF-8&separator=%2C&delimitorL=%22&delimitorR=%22&CR=%25%25%25&listfields[]=9&listfields[]=10&listfields[]=11&recordsMax=-1"
my.trackerId <- 1
my.domain <- "http://localhost/12.x/"
my.file <- paste0(my.domain, "tiki-ajax_services.php?controller=tracker&action=export_items&trackerId=", my.trackerId,"&encoding=UTF-8&separator=%2C&delimitorL=%22&delimitorR=%22&CR=%25%25%25&recordsMax=-1")


# You need to set "Admin > Control Panels > Security > HTTP Basic Authentication" (login_http_basic) to "Always"" or "SSL Only" 
# Then create a user with the following credentials in your Tiki
my.c <- GET(my.file, authenticate("exporter", "12345"))
# my.c stands for my connection. It has a list of 10 elements.
names(my.c)
# [1] "url"         "status_code" "headers"     "all_headers" "cookies"     "content"     "date"       
# [8] "times"       "request"     "handle" 

str(content(my.c))

# Fetch a guess for the encoding of the data that came from Tiki. It should be UTS-8 in most cases, but you never know (it depends on the configuration set at the local tiki instance)
my.c.encoding <- stringi::stri_enc_detect(httr::content(my.c, "raw"))
my.c.encoding
my.c.encoding <- my.c.encoding[[1]]$Encoding[1]
my.c.encoding
#my.df <- content(my.c, "text", encoding = my.c.encoding)

# Fetch content in binari form and save to plain text file on disk
bin <- httr::content(my.c, "raw")
my.tracker.file <- paste0("tracker_", my.trackerId,"_", format(Sys.Date(), "%y%m%d"),".csv")
writeBin(bin, file.path(getwd(), my.tracker.file))

my.df <- fread(file.path(getwd(), my.tracker.file), stringsAsFactors=FALSE, data.table=F)
head(my.df[,1:10])
```

## massage and cleanup the dataset
We apply an "apply" function to the whole data frame just for the sake of practising with the apply function itself, since the gsub would do it on the 2nd column, which is the only one selfnumbered which carries this html markup to show the "#" sign in front of it, as defined in teh Tracker Field definition.

```{r massage and cleanup the dataset, echo=TRUE}
#gsub("<span class='formunit'>#</span>", "", my.df[1,2], fixed=T)
my.df.c <- apply(my.df, 2, gsub, pattern="<span class='formunit'>#</span>", replacement="", fixed=T)
my.df.c[,1:10]
# Clean the Tracker field definition also for weirdnesses
#my.tfd2 <- apply(my.tfd, 2, gsub, pattern="S<U+00CD>", replacement="Sí", fixed=T)
my.tfd2 <- apply(my.tfd, 2, gsub, pattern="S\\u00cd", replacement="Si", fixed=T)
head(my.tfd2[,1:10])
#class(my.df.c) # It's been converted into a matrix!
# Convert back the object to a data.frame
my.df.c <- data.frame(my.df.c) #
my.tfd <- data.frame(my.tfd) #
my.tfd2 <- data.frame(my.tfd2) #

# Search for data for fieldId 549 in the my.df (Dataframe with data)
grep("549", colnames(my.df.c))
my.df[,202]
colnames(my.df)[202]

# Search for data for fieldId 549 in the my.tfd (Dataframe with the tracker field definition)
grep("549", my.tfd$fieldId)
my.tfd[9,]
grep("549", my.tfd2$fieldId)
my.tfd2[9,]



```

# Fetch Mysql DB Table for Tracker fields

```{r Fetch Mysql DB Table for Tracker fields}
myTrackerId <- 1
myMySQLUser <- "exporter"
myMySQLPw   <- "12345"
myTikiDb    <- "tiki12svn_trasplantaments"
myTikiTable <- "tiki_tracker_fields"
# connect to local MySQL database (host='localhost' by default)
con = dbConnect(RMySQL::MySQL(), myTikiDb, username=myMySQLUser, password=myMySQLPw)
summary(con)
dbGetInfo(con)
dbListResults(con)
db.tables <- dbListTables(con)
head(db.tables)
#tmp <- sprintf("SELECT * FROM name WHERE lname = %s", "O'Reilly")
#dbEscapeStrings(con, tmp)

my.t = dbReadTable(con, myTikiTable) # All fields from all trackers
head(my.t, 4)
dim(my.t)
# [1] 274  23

my.tfd <- base::subset(my.t, trackerId == myTrackerId) # My Tracker Fields Definition
#dim(my.tfd)
#head(my.tfd)

# You might want to Check that there are not duplicataed field definitions
#my.t.fieldIds = dbGetQuery(con, paste0("SELECT DISTINCT fieldId FROM ", myTikiTable))

# Disconnect from the MySQL connection
dbDisconnect(con)
```

```{r Test the display for a couple of radio button fields}
# Test displaying as dataframe some json-encoded data from a radio button field definition
# For instance, field 281 (raw 1 in the my.tt df) "AnoxToxMet. RNM":
my.tfd[1,"options"]
#[1] "{\"options\":[\"0=Normal\",\"1=Anormal\"]}"
fromJSON(my.tfd[1,"options"])
#$options
#[1] "0=Normal"  "1=Anormal"

# Display with row from the my.tt df object contains the values for the definition of fieldId 9 (Sexo -- 9)
#which(my.tfd$fieldId==9)
# [1] 135
#my.tfd[which(my.tfd$fieldId==9),"options"]
# [1] "{\"options\":[\"0=Mujer\",\"1=Varon\",\"99=ns/nc\"]}"
my.options <- unlist(fromJSON(my.tfd[which(my.tfd$fieldId==9),"options"]))
my.op.tmp <- unlist(str_split(my.options, "="))

#head(my.df[,1:10])
#length(colnames(my.df))
#[1] 274
#str(my.df[,"Sexo -- 9"])

my.field.colname <- "Sexo -- 9" # As a Column name of my.df
my.field.name <- unlist(str_split(my.field.colname, " -- "))[1]
my.field.id <- unlist(str_split(my.field.colname, " -- "))[2]
my.field.data <- as.numeric(my.df[,my.field.colname])

#Recode something like 
                  # "0"     "Mujer" "1"     "Varon" "99"    "ns/nc"
                  # into something like:
                  # "Mujer" = 0, "Varon" = 1, "ns/nc" = 99
cc <- 0 # loop counter
my.options <- NULL
my.op.tmp.number <- NULL
my.op.tmp.label <- NULL
# We generate two clean vectors with the information of the numbers (option values in the form)
# and the corresponding labels shown in the form, for further merging of the information 
# in the memisc::as.item function.
for (ii in seq(1, length(my.op.tmp), by=2)) {
  cc <- cc+1
  my.op.tmp.number[cc] <- my.op.tmp[ii] 
  my.op.tmp.label[cc]  <- my.op.tmp[ii+1]
}

#my.op.tmp.number # Clea vector of numbers (options in the form)
#my.op.tmp.label # Clean vector of labels corresponding to the previous options

# If we were to do it by hand we would do it like this:
#memisc::labels(my.field.data) <- c("Mujer" = 0,
#                           "Varon" = 1,
#                           "ns/nc" = 99)
# However, with standard "assign" or "factor" or equivalent functions, it doesn't work:
#memisc::labels(my.field.data) <- c("\"Mujer\"" = 0,  "\"Varon\"" = 1,  "\"ns/nc\"" = 99)

# Therefore we need to use the memisc:as.item function to properly merge all the required info in place
my.field.labels <- as.item(my.field.data, 
                      labels=structure(my.op.tmp.number, 
                                       names=my.op.tmp.label),
                      missing.values=99,
                      annotation = c(
                        description=my.field.name
                        )
                      )
memisc::labels(my.field.labels)

view_df(data.frame(my.field.data))
my.field.data <- set_labels(my.field.data, memisc::labels(my.field.labels))
get_labels(my.field.data, include.values = T)
view_df(data.frame(my.field.data))

```

# Loop to add value/label pairs to all variables where needed

```{r Loop to add value/label pairs to all variables where needed}
# Have a look at the columns and some of their values of the tracker field definitions (my.tfd)
head(my.tfd)

# > table(my.tfd$type)
# 
#    a    C    d    D    f    h    M math    n    q    R    t    u 
#    1    5   26    1   21   47   13    1   42    1   80   35    1
# Tracker field Codes that contain value=label pairs
#Sys.getlocale()
Sys.setlocale('LC_ALL','C') # Needed to avoid this warning message: "input string 90 is invalid in this locale", etc. Adn this line had this code: "1=S\xed\" (meaning "1=Sí").
#my.tfd$options[90]
table(my.tfd[grep("options", my.tfd$options, fixed=TRUE),"type"])
#  D  M  R  d 
#  1 13 80 26 
#
# D: Dropdown with other
# M: Multiselect
# R: Radio button
# d: dropdown
#
# See this page to check their correspondence
# https://dev.tiki.org/Tracker+Field+Types

# Special handling will be needed also for field type:
# f: Date and Time

# FROM TRACKER FIELD DEFINITION
# Indexes of the data frame that correspond to fields which contain value:label pairs (as options)
fields.with.options.idx <- grep("options", my.tfd$options, fixed=TRUE)
  #head(my.tfd[fields.with.options.idx,])
  #head(my.tfd[fields.with.options.idx, c("type","options")])
# FieldId's for those cases of tracker fields (fields which contain value:label pairs, as options)
fields.with.options.fieldId <- my.tfd[fields.with.options.idx,"fieldId"]

# FROM TRACKER DATA
# Get the column numbers of the variables that contain data that needs to be labelled properly
# Identify the data columns that require value:label pair fixing
#head(my.df.c)

for (ff in 1:length(fields.with.options.fieldId)) {
  #ff <- 61; ff <- 1 # f_id 281; ff <- 2 # f_id 280; ff <- 3 # f_id 270...; ff <- 5 # f_id 549 
  
  # Report progress
  cat(paste0(" (", ff, "/", length(fields.with.options.fieldId), ")", " Processing fieldId: ", fields.with.options.fieldId[ff], "\n"))

  # Get the options for that field
  my.options <- unlist(fromJSON(my.tfd[which(my.tfd$fieldId==fields.with.options.fieldId[ff]),
                                       "options"]
                                )
                       )
  # Split the options in chunks
  my.op.tmp <- unlist(str_split(my.options, "="))
  
  # Get the field name
  my.tfd[which(my.tfd["fieldId"]==fields.with.options.fieldId[ff]), "name"]
  
  my.df.c.col.idx <- grep(paste0("-- ", fields.with.options.fieldId[ff], "$"), colnames(my.df.c), fixed=FALSE)
  
  #my.df.c <- data.frame(my.df.c)
  #my.df.c[,my.df.c.col.idx]
  
  my.field.colname <- colnames(my.df.c)[my.df.c.col.idx] # "Sexo -- 9" # As a Column name of my.df
  my.field.name <- unlist(str_split(my.field.colname, " -- "))[1]
  my.field.id <- unlist(str_split(my.field.colname, " -- "))[2]
  my.field.data <- as.numeric(my.df[,my.field.colname])

  #Recode something like 
                    # "0"     "Mujer" "1"     "Varon" "99"    "ns/nc"
                    # into something like:
                    # "Mujer" = 0, "Varon" = 1, "ns/nc" = 99
  cc <- 0 # loop counter
  my.options <- NULL
  my.op.tmp.number <- NULL
  my.op.tmp.label <- NULL
  # We generate two clean vectors with the information of the numbers (option values in the form)
  # and the corresponding labels shown in the form, for further merging of the information 
  # in the memisc::as.item function.
  for (ii in seq(1, length(my.op.tmp), by=2)) {
    cc <- cc+1
    my.op.tmp.number[cc] <- my.op.tmp[ii] 
    my.op.tmp.label[cc]  <- my.op.tmp[ii+1]
  }
  
  # Therefore we need to use the memisc:as.item function to properly merge all the required info in place
  my.field.data.labels <- as.item(my.field.data, 
                                    labels=structure(my.op.tmp.number, 
                                                     names=my.op.tmp.label),
                                    missing.values=99,
                                    annotation = c(
                                      description=my.field.name
                                      )
                                    )
  # class(my.df.c[,my.field.colname])
  #memisc::labels(my.df.c[,my.field.colname])
  # class(my.field.data)
  #memisc::labels(my.field.data)
  # Convert values from char to numeric class
  #my.df.c[,my.field.colname] <- as.numeric(my.df.c[,my.field.colname])
          
  my.field.data.sj <- set_labels(my.field.data,
                                               memisc::labels(my.field.data.labels))
  # Set also labels in the format expected by sjmisc with set_labels()

  #head(my.df.c[,my.field.colname])

  # view_df(data.frame(my.field.data.sj))
  
}
 str(my.df.c)


```

# Convert the tracker data to data.set for package memisc

```{r Convert the tracker data to data.set for package memisc}
# Our data is still stored as a matrix.
#class(my.df.c)

# Therefore we need to convert the clean matrix of data, into a data.frame, and convert it to class data.set from package memisc
my.ds <- as.data.set(data.frame(my.df.c)) 
class(my.ds)
```

# Produce some description out of the data

```{r Produce some description out of the data}
require(sjmisc)
require(sjPlot)
view_df(data.frame(my.df.c))
#view_df(data.frame(my.df.c), showFreq = TRUE, showPerc = TRUE) #  # As before, but with frequencies and percentages (as a "codebook")
view_df(data.frame(my.ds))
#view_df(data.frame(my.ds), showFreq = TRUE, showPerc = TRUE) #  # As before, but with frequencies and percentages (as a "codebook")

sjt.frq (data.frame(my.df.c)[,10]) # For one variable, such as "Sexo -- 9", which is #10 here.

```

# Tweak data and labels through GUI (Optional)


```{r Tweak data and labels through GUI (Optional)}
require(Rz)
Rz()

```

# Create Codebook (optional)

```{r Create Codebook (optional)}
# CodeBooks
# ----------
# Add here the commands to create a codebook from memisc, in case we need it. But since we don't, it seems, then we skip this part, for the time being.


```

# Some ways to make descriptive statistics

```{r Some ways to make descriptive statistics}
# See http://r-es.org/7jornadasR/ponencias/jose_ignacio_casas.pdf (Slide 21 onwards)
dim(my.t.fieldIds)

#description(my.df[,1:10])
# Try some packaages for a basic descriptive statistics out of some data set
#
# compareGroups: 
# https://cran.r-project.org/web/packages/compareGroups/vignettes/compareGroups_vignette.pdf
#
# Describer (+ dplyr + knitr +reshape2): https://github.com/paulhendricks/describer
#
# Check vignettes of DescTools: http://www.r-pkg.org/pkg/DescTools
# https://cran.r-project.org/web/packages/DescTools/vignettes/DescToolsCompanion.pdf
# https://cran.r-project.org/web/packages/DescTools/vignettes/TablesInR.pdf
#
# memisc
# http://www.elff.eu/memisc/gentab/
# http://www.elff.eu/memisc/ftable-matrix/


# Handling of values and labels:
# http://www.elff.eu/memisc/items/
## SEE: http://www.elff.eu/memisc/items/#codebooks-of-survey-items


#install.packages("sjPlot")
#install.packages("sjmisc")
#install.packages("stringr")

# "Quantitative Discourse Analysis Package: Bridging the Gap Between Qualitative Data and Quantitative Analysis"
#install.packages("qdap")
#library(qdap)

### EXAMPLE with pre-set data frame by hand
marca<-c("opel","renault","renault")
model<-c("corsa","laguna","modus")
cilindrada<-c(1.2,1.9,1.5)
color<-c("blanc","vermell","violeta")
cotxes<-data.frame(marca,model,cilindrada,color)
cotxes
# init default theme for plots
#sjp.setTheme(geom.label.size = 2.5, axis.title.size = .9, axis.textsize = .9)
#sjp.frq(cotxes$marca)
#str(my.df)
#sjp.frq(my.df[,1]) # this fails for unknown reason
#my.df <- set_labels(my.df, c(str_split(colnames(my.df), "\\.")[[1]][1],
#                                 str_split(colnames(my.df), "\\.")[[2]][1],
#                                 str_split(colnames(my.df), "\\.")[[3]][1]))
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r Store objects into an Rda, echo=FALSE}
save(my.c,
     my.df,
     my.df.c,
     my.tfd,
     my.tracker.file,
     my.ds,
     file=my.rda)
```

```{r Stored session info, echo=TRUE}
###################################################
# Store session info (package versions, etc) in the logs folder
###################################################
sink(file.path(paste0("log_", format(Sys.Date(), format="%y%m%d"), "_", aID, ".txt")))
cat("Sys.info() : \n")
cat("--------------------\n")
data.frame(Sys.info())
if (exists("biocValid")) {
  cat("\n\nbiocValid() : \n")
  cat("--------------------\n")
  biocValid()
} else { # Only show sessionInfo() if no biocValid() is found since it's already included in it.
  cat("\n\nsessionInfo() : \n")
  cat("--------------------\n")
  sessionInfo()
}
sink()

```

