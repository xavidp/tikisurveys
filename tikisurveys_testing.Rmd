---
title: "Tiki surveys Testing"
author: "Xavier de Pedro Puente"
date: "25/01/2016"
output: html_document
---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## Install packages

```{r Install packages, echo=FALSE}
#############################
# Package dependencies
#############################
## ----librerias, eval=TRUE------------------------------------------------
## Bioconductor
installifnot <- function (pckgName){
  if(!(require(pckgName, character.only=TRUE))){
    source("http://Bioconductor.org/biocLite.R")
    biocLite(pckgName)
  }
}
# Names of packages to be installed from BIOCONDUCTOR if not present yet in this machine
pBIOC <- NULL

if( any(!pBIOC %in% rownames(installed.packages())) ){
  installifnot(pBIOC[!pBIOC %in% rownames(installed.packages())])
}

# Names of packages to be installed from CRAN if not present yet in this machine
pCRAN <- c("devtools",
           "sjPlot",
           "sjmisc",
           "ggplot2",
           "httr",
           "stringi",
           "stringr",
           "data.table",
           "RMySQL",
           "jsonlite",
           "memisc")

if( any(!pCRAN %in% rownames(installed.packages())) ){
  install.packages(pCRAN[!pCRAN %in% rownames(installed.packages())])
}

if(!require(rCharts)) install_github('rCharts', 'ramnathv')

#Load required libraries
packages <- c(pBIOC, pCRAN)
for (ii in 1:length(packages)) {
  require(as.character(packages[ii]), character.only=TRUE)
}

# if memisc fails for some reason on CRAN, like the package is just updated online but CRAN still points to the old package which is not available anymore, then you can install through github:
#devtools::install_github("melff/memisc",subdir="pkg")
```

## Load data from Rda (if available)

```{r Load data from Rda (if available), echo=TRUE}
my.rda <- "mySession.Rda"

# load it from disk (if present on disk)
if (file.exists(file.path(getwd(), my.rda))) {
  ## ----loadData------------------------------------------------------------
  load(file=file.path(getwd(), my.rda))
}
```

## Fetch data from the trasplantaments db

```{r, echo=T}
aID <- "TikiTrackerDB" # Analysis ID

# If your tiki is not under localhost, adapt the path below for my.file
#my.file <- "http://localhost/12.x/tiki-ajax_services.php?controller=tracker&action=export_items&trackerId=1&encoding=UTF-8&separator=%2C&delimitorL=%22&delimitorR=%22&CR=%25%25%25&listfields[]=9&listfields[]=10&listfields[]=11&recordsMax=-1"
my.trackerId <- 1
my.domain <- "http://localhost/12.x/"
my.file <- paste0(my.domain, "tiki-ajax_services.php?controller=tracker&action=export_items&trackerId=", my.trackerId,"&encoding=UTF-8&separator=%2C&delimitorL=%22&delimitorR=%22&CR=%25%25%25&recordsMax=-1")


# You need to set "Admin > Control Panels > Security > HTTP Basic Authentication" (login_http_basic) to "Always"" or "SSL Only" 
# Then create a user with the following credentials in your Tiki
my.c <- GET(my.file, authenticate("exporter", "12345"))
# my.c stands for my connection. It has a list of 10 elements.
names(my.c)
# [1] "url"         "status_code" "headers"     "all_headers" "cookies"     "content"     "date"       
# [8] "times"       "request"     "handle" 

str(content(my.c))

# Fetch a guess for the encoding of the data that came from Tiki. It should be UTS-8 in most cases, but you never know (it depends on the configuration set at the local tiki instance)
my.c.encoding <- stringi::stri_enc_detect(httr::content(my.c, "raw"))
my.c.encoding
my.c.encoding <- my.c.encoding[[1]]$Encoding[1]
my.c.encoding
#my.df <- content(my.c, "text", encoding = my.c.encoding)

# Fetch content in binari form and save to plain text file on disk
bin <- httr::content(my.c, "raw")
my.tracker.file <- paste0("tracker_", my.trackerId,"_", format(Sys.Date(), "%y%m%d"),".csv")
writeBin(bin, file.path(getwd(), my.tracker.file))

my.df <- fread(file.path(getwd(), my.tracker.file), stringsAsFactors=FALSE, data.table=F)
head(my.df[,1:10])
```

## massage and cleanup the dataset
We apply an "apply" function to the whole data frame just for the sake of practising with the apply function itself, since the gsub would do it on the 2nd column, which is the only one selfnumbered which carries this html markup to show the "#" sign in front of it, as defined in teh Tracker Field definition.

```{r massage and cleanup the dataset, echo=TRUE}
gsub("<span class='formunit'>#</span>", "", my.df[1,2], fixed=T)
my.df.c <- apply(my.df, 2, gsub, pattern="<span class='formunit'>#</span>", replacement="", fixed=T)
my.df.c[,1:10]

```

# 

This package doesn't See Presentation from:
http://files.meetup.com/1781511/useR%20Vignette%20-%20Accessing%20Databases%20from%20R%20-%2020110504.pdf

```{r Fetch Mysql DB Table for Tracker fields}
myTrackerId <- 1
myMySQLUser <- "exporter"
myMySQLPw   <- "12345"
myTikiDb    <- "tiki12svn_trasplantaments"
myTikiTable <- "tiki_tracker_fields"
# connect to local MySQL database (host='localhost' by default)
con = dbConnect(RMySQL::MySQL(), myTikiDb, username=myMySQLUser, password=myMySQLPw)
summary(con)
dbGetInfo(con)
dbListResults(con)
db.tables <- dbListTables(con)
head(db.tables)
#tmp <- sprintf("SELECT * FROM name WHERE lname = %s", "O'Reilly")
#dbEscapeStrings(con, tmp)

my.t = dbReadTable(con, myTikiTable) # All fields from all trackers
head(my.t, 4)
dim(my.t)
# [1] 274  23

my.tfd <- base::subset(my.t, trackerId == myTrackerId) # My Tracker Fields Definition
dim(my.tfd)
head(my.tfd)
my.t.fieldIds = dbGetQuery(con, paste0("SELECT DISTINCT fieldId FROM ", myTikiTable))

# Test displaying as dataframe some json-encoded data from a radio button field definition
# For instance, field 281 (raw 1 in the my.tt df) "AnoxToxMet. RNM":
my.tfd[1,"options"]
#[1] "{\"options\":[\"0=Normal\",\"1=Anormal\"]}"
fromJSON(my.tt[1,"options"])
#$options
#[1] "0=Normal"  "1=Anormal"

# Display with row from the my.tt df object contains the values for the definition of fieldId 9 (Sexo -- 9)
#which(my.tfd$fieldId==9)
# [1] 135
#my.tfd[which(my.tfd$fieldId==9),"options"]
# [1] "{\"options\":[\"0=Mujer\",\"1=Varon\",\"99=ns/nc\"]}"
my.options <- unlist(fromJSON(my.tfd[which(my.tfd$fieldId==9),"options"]))
my.op.tmp <- unlist(str_split(my.options, "="))


#head(my.df[,1:10])
#length(colnames(my.df))
#[1] 274
#str(my.df[,"Sexo -- 9"])

my.field.colname <- "Sexo -- 9" # As a Column name of my.df
my.field.name <- unlist(str_split(my.field.colname, " -- "))[1]
my.field.id <- unlist(str_split(my.field.colname, " -- "))[2]
my.field.data <- as.numeric(my.df[,my.field.colname])

cc <- 0 # loop counter
#Recode something like 
                  # "0"     "Mujer" "1"     "Varon" "99"    "ns/nc"
                  # into something like:
                  # "Mujer" = 0, "Varon" = 1, "ns/nc" = 99
                  my.options <- NULL
                  for (ii in seq(1, length(my.op.tmp), by=2)) {
                    # ii <- 1
                    cc <- cc+1
                    my.options[cc] <- my.op.tmp[ii+1]
                    assign(my.options[cc], as.factor(my.op.tmp[ii]))
#                    memisc::labels(my.field.data) <- c(memisc::labels(my.field.data),
#                                                       my.op.tmp[ii+1])
#                      my.options <- paste0("\"", my.op.tmp[ii+1], "\" = ", as.numeric(my.op.tmp[ii]))

                  }
memisc::labels(my.field.data) <- labels(my.options)
memisc::labels(my.options)
memisc::labels(my.field.data)
                  #  print(my.options)
#memisc::labels(my.field.data) <- eval(parse(text =my.options))
#class(my.options)
#length(my.options)
rm(my.field.data)

c("\"Mujer\"" = 0,  "\"Varon\"" = 1,  "\"ns/nc\"" = 99)
memisc::labels(my.field.data) <- c("Mujer" = 0,
                           "Varon" = 1,
                           "ns/nc" = 99)
labels(my.field.data)
x <- as.item(my.df[,my.field],
             labels=c(
                 paste(my.options, collapse=",")
               ),
             missing.values=99,
             annotation = c(
               description=my.field.name
               )
             )
str(x)

# CodeBooks
# ----------
# Add here the commands to create a codebook from memisc
# See http://r-es.org/7jornadasR/ponencias/jose_ignacio_casas.pdf (Slide 21 onwards)
dim(my.t.fieldIds)

dbDisconnect(con)

```

```{r Some ways to make descriptive statistics}
#description(my.df[,1:10])
# Try some packaages for a basic descriptive statistics out of some data set
#
# compareGroups: 
# https://cran.r-project.org/web/packages/compareGroups/vignettes/compareGroups_vignette.pdf
#
# Describer (+ dplyr + knitr +reshape2): https://github.com/paulhendricks/describer
#
# Check vignettes of DescTools: http://www.r-pkg.org/pkg/DescTools
# https://cran.r-project.org/web/packages/DescTools/vignettes/DescToolsCompanion.pdf
# https://cran.r-project.org/web/packages/DescTools/vignettes/TablesInR.pdf
#
# memisc
# http://www.elff.eu/memisc/gentab/
# http://www.elff.eu/memisc/ftable-matrix/


# Handling of values and labels:
# http://www.elff.eu/memisc/items/
## SEE: http://www.elff.eu/memisc/items/#codebooks-of-survey-items


# And set that tracker id to allow registered to export tracker items
#colnames(my.df) <- c("f_9", "f_10", "f_11")
#unlist(str_split(colnames(my.df), "\\."))[1]
#str_split(colnames(my.df), "\\.")[[1]][1] # field name from f_9 in this example
#str_split(colnames(my.df), "\\.")[[2]][1] # field name from f_10 in this example
#str_split(colnames(my.df), "\\.")[[3]][1] # field name from f_11 in this example


#install.packages("sjPlot")
#install.packages("sjmisc")
#install.packages("stringr")

# "Quantitative Discourse Analysis Package: Bridging the Gap Between Qualitative Data and Quantitative Analysis"
#install.packages("qdap")
#library(qdap)

### EXAMPLE with pre-set data frame by hand
marca<-c("opel","renault","renault")
model<-c("corsa","laguna","modus")
cilindrada<-c(1.2,1.9,1.5)
color<-c("blanc","vermell","violeta")
cotxes<-data.frame(marca,model,cilindrada,color)
cotxes
# init default theme for plots
#sjp.setTheme(geom.label.size = 2.5, axis.title.size = .9, axis.textsize = .9)
#sjp.frq(cotxes$marca)
#str(my.df)
#sjp.frq(my.df[,1]) # this fails for unknown reason
#my.df <- set_val_labels(my.df, c(str_split(colnames(my.df), "\\.")[[1]][1],
#                                 str_split(colnames(my.df), "\\.")[[2]][1],
#                                 str_split(colnames(my.df), "\\.")[[3]][1]))
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r Store objects into an Rda, echo=FALSE}
save(my.df,
     file=my.rda)
```

```{r Stored session info, echo=TRUE}
###################################################
# Store session info (package versions, etc) in the logs folder
###################################################
sink(file.path(paste0("log_", format(Sys.Date(), format="%y%m%d"), "_", aID, ".txt")))
cat("Sys.info() : \n")
cat("--------------------\n")
data.frame(Sys.info())
if (exists("biocValid")) {
  cat("\n\nbiocValid() : \n")
  cat("--------------------\n")
  biocValid()
} else { # Only show sessionInfo() if no biocValid() is found since it's already included in it.
  cat("\n\nsessionInfo() : \n")
  cat("--------------------\n")
  sessionInfo()
}
sink()

```

